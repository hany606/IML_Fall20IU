##############################################
# Student information: Hany Hamed
# Group: BS18-ROB
# Project Contest IML course Fall 2020
# This code is only for generating the dataset from the subset of mnist that from colab
# Note for credits: I would like to thank my collouge Yusuf Mesbah (@Yusufroshdy) for his hints, insights and his help for some of the augmentations and optimization for CNN architechtures
# There are many combinations of datasets that has been generated, used and tested and this gen file is just a subset of the working generated dataset
##############################################
# -*- coding: utf-8 -*-
"""ML_Project_core1_(2)_(1).ipynb

Automatically generated by Colaboratory.
# Install libraies
"""

# !pip3 install git+https://github.com/aleju/imgaug.git
# !pip3 install imagecorruptions
# !pip3 install tqdm

"""# 1. Import libraries"""
from sklearn.model_selection import train_test_split
from tensorflow.keras.preprocessing.image import ImageDataGenerator
import numpy as np
from PIL import Image as pImage
from matplotlib import pyplot as plt
from scipy.ndimage import gaussian_filter
import cv2
import imgaug.augmenters as iaa
from tqdm import tqdm
np.random.seed(123)


"""# 2. Import the dataset

## Only colab
"""
path = ""
X1, Y1 = np.load(path+"x.npy"), np.load(path+"y.npy")
X, Y = X1, Y1
print(X.shape, Y.shape)
x_train, x_test, y_train, y_test = train_test_split(X, Y, test_size=0.2, stratify=Y, shuffle=True, random_state=123)



"""# 5. Callbacks (Augmentations, early stopping, tensorboard, ...etc)"""

# Source: https://www.kaggle.com/fraluc/cnn-keras-with-custom-data-augmentation-99-52

# Gaussian Blur
def gaussian_blur(X, sigma=0.5):
  return gaussian_filter(X,sigma)

# Gaussian Noise -- Salt an pepper noise
# Source: https://gist.github.com/Prasad9/077050d9a63df17cb1eaf33df4158b19
def gaussian_noise(X):
  # Need to produce a copy as to not modify the original image
  X_img = X
  row, col, _ = X_img.shape
  salt_vs_pepper = 0.3
  amount = 0.05
  num_salt = np.ceil(amount * X_img.size * salt_vs_pepper)
  num_pepper = np.ceil(amount * X_img.size * (1.0 - salt_vs_pepper))

  # Add Salt noise
  coords = [np.random.randint(0, i - 1, int(num_salt)) for i in X_img.shape[:2]]
  X_img[coords[0], coords[1], :] = 255

  # Add Pepper noise
  coords = [np.random.randint(0, i - 1, int(num_pepper)) for i in X_img.shape[:2]]
  X_img[coords[0], coords[1], :] = 0
  return X_img

# https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_morphological_ops/py_morphological_ops.html#morphological-ops
# Dilation
def dilation(X):
  return cv2.dilate(X,np.ones((2,2),np.uint8),iterations = 1).reshape(28,28,1)

# erosion
def erosion(X):
  return cv2.erode(X,np.ones((2,2),np.uint8),iterations = 1).reshape(28,28,1)

# opening
def opening(X):
  return cv2.morphologyEx(X, cv2.MORPH_OPEN, np.ones((2,2),np.uint8),iterations = 1).reshape(28,28,1)

# closing
def closing(X):
  return cv2.morphologyEx(X, cv2.MORPH_CLOSE, np.ones((2,2),np.uint8),iterations = 1).reshape(28,28,1)

def gradient(X):
  return cv2.morphologyEx(X, cv2.MORPH_GRADIENT, np.ones((2,2),np.uint8),iterations = 1).reshape(28,28,1)

   
def inverted(X):
  filling_val = [255, 127, 80, 180, 150]
  return np.array(abs((X) - np.full((X.shape),np.random.choice(filling_val)))).reshape(28,28,1)
  
patterns = []
def load_patterns():
  path = "patterns/"
  for i in range(3):
    im = pImage.open(f"{path}pat{i+1}.png")
    im_np = np.asarray(im).reshape((28,28,1))
    patterns.append(im_np)
load_patterns()
def pattern_add(X):
  i = np.random.choice(3)
  X = X + patterns[i]
  return X

def bounding_box(X):
  img = np.array(X, np.uint8)
  ret, thresh = cv2.threshold(img , 127, 255, cv2.THRESH_BINARY)
  # print(thresh.shape)
  contours, hierarchy = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
  if(len(contours) < 3): # in order to not work with noisy image as it will be corrupted
    c = max(contours, key = cv2.contourArea)
    x,y,w,h = cv2.boundingRect(c)
#     img = cv2.rectangle(img,(x,y),(x+w,y+h),(255,255,255),1)
    new_img = (img)[y:y+h, x:x+w]
    img = cv2.resize(new_img, (28,28))

  return img.reshape((28,28,1))

# bg_tot = []
# def load_bg():
#   path = "bg/"
#   for i in range(10):
#     im = pImage.open(f"{path}bg{i+1}.jpeg")
#     im_np = np.asarray(im)
#     # print(im_np.shape)
#     bg_tot.append(im_np)
# load_bg()

# def bg_mnist(X): 
#   p = np.random.choice(9)
#   img = np.array(X, np.uint8)
#   ret, thresh = cv2.threshold(img , 127, 255, cv2.THRESH_BINARY)
#   X = thresh.reshape((28,28,1))*255
#   bg_big = bg_tot[p+1]
#   x_coord, y_coord = np.random.randint(bg_big.shape[1]-28), np.random.randint(bg_big.shape[0]-28)
#   bg = bg_big[y_coord:y_coord+28, x_coord:x_coord+28]
#   for i in range(28):
#     for j in range(28):
#       if(X[i,j,0]  == 0): 
#         #print(bg[i,j])
#         X[i,j,0] = bg[i,j][0]
#       else:
#         if(p > 0.5):
#           X[i,j,0] = 255
#         else:
#           X[i,j, 0] = 0 
#   return X  


def imgaug_pre(X):
  sometimes = lambda aug: iaa.Sometimes(0.5, aug)
  # iaa.SomeOf((0, 5), [])

  seq = iaa.Sequential([
    sometimes(iaa.ElasticTransformation(alpha=(0, 2.5), sigma=2)),
    sometimes(iaa.Sharpen(alpha=(0, 0.5))), # sharpen images
    sometimes(iaa.OneOf([
        iaa.GaussianBlur(sigma=(0, 2.0)),
        iaa.MotionBlur(k=3)
    ])),
    sometimes(iaa.AdditiveGaussianNoise(loc=1, scale=(0.0, 70), per_channel=0.5)),
  ])
  return seq(images=X.copy())


def preprocess_func(X):
  augs = [
          # bounding_box,0.7, #c: 0.5, 0.7, 0.8, x1
          # imgaug_pre,0.4,
          gaussian_blur,0.2, #c: 0.1, 0.2, x0.5
          dilation,0.2,#c: 0.1, 0.2, x0.3
          erosion,0.2,#c: 0.1, 0.2, x0.3
          gaussian_noise, 0.5,
          opening,0.2, #c: 0.1, 0.15, x0.2
          closing,0.2, #c: 0.1, 0.15, x0.2
          pattern_add, 0.5,
          inverted,0.4, #c: 0.1, 0.3, 0.4, x0.6
          ]
          
  num_augs = len(augs)
  p = np.random.random_sample((num_augs,))
  # print(p)

  for i in range(num_augs//2):
    thresh = augs[i*2+1]
    aug = augs[i*2]
    if(p[i] <= thresh):
      X = aug(X.copy())
  return X

generator = ImageDataGenerator(preprocessing_function=preprocess_func,
                              featurewise_center=False,  # set input mean to 0 over the dataset
                              samplewise_center=False,  # set each sample mean to 0
                              featurewise_std_normalization=False,  # divide inputs by std of the dataset
                              samplewise_std_normalization=False,  # divide each input by its std
                              zca_whitening=False,  # apply ZCA whitening
                              zca_epsilon=1e-06,    # epsilon for ZCA whitening. Default is 1e-6.
                              rotation_range=15,  # randomly rotate images in the range (degrees, 0 to 180) 30
                              zoom_range = 0.005,#0.1, # Randomly zoom image 
                              width_shift_range=0.1,#0.2,  # randomly shift images horizontally (fraction of total width) 0.1
                              height_shift_range=0.1,#0.3,  # randomly shift images vertically (fraction of total height) 0.1
                              horizontal_flip=False,  # randomly flip images
                              vertical_flip=False,
                              brightness_range=[1,1.5],#[30,80], # Tuple or list of two floats. Range for picking a brightness shift value from.
                              shear_range=0.3,
                              channel_shift_range=0.0,
                              fill_mode="nearest",
                              cval=0.0,
                              rescale=None,
                              data_format=None,
                              validation_split=0.15,)


def preprocess_func_mod(X):
  augs = [
          bounding_box,0.8, #c: 0.5, 0.7, 0.8, x1
          imgaug_pre,1,
          ]
          
  num_augs = len(augs)
  p = np.random.random_sample((num_augs,))
  # print(p)

  for i in range(num_augs//2):
    thresh = augs[i*2+1]
    aug = augs[i*2]
    if(p[i] <= thresh):
      X = aug(X.copy())
  return X

generator_imgaug = ImageDataGenerator(preprocessing_function=preprocess_func_mod)
aug_iter = generator_imgaug.flow(x_train, y_train, batch_size=1, seed=7)
X2, Y2 = [], []

for i in tqdm(range(50000)):
	# convert to unsigned integers
  image, image_label = next(aug_iter)
  X2.append(np.array(image).reshape((28,28,1)))
  Y2.append(image_label[0])

X, Y = np.vstack([X,np.array(X2)]), np.hstack([Y,np.array(Y2)])
# X,Y = np.array(X2), np.array(Y2)
# print(X.shape)
postfix = f"{2}"
np.save(f"x_aug{postfix}.npy", X)
np.save(f"y_aug{postfix}.npy", Y)
X, Y = np.load(f"x_aug{postfix}.npy"), np.load(f"y_aug{postfix}.npy")
print(X.shape)
x_train, x_test, y_train, y_test = train_test_split(X, Y, test_size=0.2, stratify=Y, shuffle=True, random_state=123)


# def preprocess_func_imgaug(X):
#   augs = [
#           bounding_box,0.8, #c: 0.5, 0.7, 0.8, x1
#           imgaug_pre,1,
#           ]
          
#   num_augs = len(augs)
#   p = np.random.random_sample((num_augs,))
#   for i in range(num_augs//2):
#     thresh = augs[i*2+1]
#     aug = augs[i*2]
#     if(p[i] <= thresh):
#       X = aug(X.copy())
#   return X

# def preprocess_func_self_implementation(X):
#   augs = [
#           bounding_box,0.8, #c: 0.5, 0.7, 0.8, x1
#           # imgaug_pre,0.4,
#           gaussian_blur,0.2, #c: 0.1, 0.2, x0.5
#           dilation,0.2,#c: 0.1, 0.2, x0.3
#           erosion,0.2,#c: 0.1, 0.2, x0.3
#           gaussian_noise, 0.5,
#           # opening,0.2, #c: 0.1, 0.15, x0.2
#           # closing,0.2, #c: 0.1, 0.15, x0.2
#           pattern_add, 0.5,
#           inverted,0.2, #c: 0.1, 0.3, 0.4, x0.6
#           ]
          
#   num_augs = len(augs)
#   p = np.random.random_sample((num_augs,))
#   # print(p)

#   for i in range(num_augs//2):
#     thresh = augs[i*2+1]
#     aug = augs[i*2]
#     if(p[i] <= thresh):
#       X = aug(X.copy())
#   return X

# def preprocess_func_mod(X):
#   p = np.random.random()
#   if(p >= 0 and p <= 25):
#     X = salt_pepper_bg(X.copy())
#   elif(p > 25 and p <= 50):
#     X = bg_mnist(X.copy())
#   elif(p > 50 and p <= 75):
#     X = preprocess_func_imgaug(X.copy()) 
#   else:
#     X = preprocess_func_self_implementation(X.copy()) 
#   return X

# generator_imgaug = ImageDataGenerator(preprocessing_function=preprocess_func_mod)
# aug_iter = generator_imgaug.flow(x_train, y_train, batch_size=1, seed=7)
# X2, Y2 = [], []

# for i in tqdm(range(150000)):
# 	# convert to unsigned integers
#   image, image_label = next(aug_iter)
#   X2.append(np.array(image).reshape((28,28,1)))
#   Y2.append(image_label[0])

# X, Y = np.vstack([X,np.array(X2)]), np.hstack([Y,np.array(Y2)])
# # X,Y = np.array(X2), np.array(Y2)
# # print(X.shape)
# postfix = f"_all_aug2"#f"_new{2}"
# np.save(f"x_aug{postfix}.npy", X)
# np.save(f"y_aug{postfix}.npy", Y)
# X, Y = np.load(f"x_aug{postfix}.npy"), np.load(f"y_aug{postfix}.npy")
# print(X.shape)
# x_train, x_test, y_train, y_test = train_test_split(X, Y, test_size=0.2, stratify=Y, shuffle=True, random_state=123)

"""## Plot augmented data"""

# # iterator
# aug_iter = generator.flow(x_train, batch_size=1)

# nc = 10
# # generate samples and plot
# fig, ax = plt.subplots(nrows=1, ncols=nc, figsize=(15,15))

# # generate batch of images
# for i in range(nc):

# 	# convert to unsigned integers
# 	image = next(aug_iter)[0]
 
# 	# plot image
# 	ax[i].imshow(image.squeeze(), cmap='gray')
# 	ax[i].axis('off')
# plt.show()